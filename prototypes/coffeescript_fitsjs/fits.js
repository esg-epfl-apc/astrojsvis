// Generated by CoffeeScript 2.7.0
(function() {
    var Base, BinaryTable, CompressedImage, DataUnit, Decompress, FITS, HDU, Header, HeaderVerify, Image, ImageUtils, Parser, Table, Tabular;

    if (this.astro == null) {
        this.astro = {};
    }

    Base = class Base {
        static include(obj) {
            var key, value;
            for (key in obj) {
                value = obj[key];
                this.prototype[key] = value;
            }
            return this;
        }

        static extend(obj) {
            var key, value;
            for (key in obj) {
                value = obj[key];
                this[key] = value;
            }
            return this;
        }

        proxy(func) {
            return () => {
                return func.apply(this, arguments);
            };
        }

        invoke(callback, opts, data) {
            var context;
            context = (opts != null ? opts.context : void 0) != null ? opts.context : this;
            if (callback != null) {
                return callback.call(context, data, opts);
            }
        }

    };

    Parser = (function() {
        class Parser extends Base {

            // FITS objects are constructed using either
            // 1) Path to a remote FITS file
            // 2) Native File object

            // First argument is either a path or File object
            // Second argument is a callback to execute after
            // initialization is complete
            // Third argument is a set of options that may be passed
            // to the callback.  If opts has the context key, the callback
            // is executed with respect to that context.
            constructor(arg, callback1, opts1) {
                var xhr;
                super();
                this.arg = arg;
                this.callback = callback1;
                this.opts = opts1;
                // Storage for header dataunits
                this.hdus = [];

                // Set initial state for parsing buffer
                // Blocks of 2880 will be read until an entire header is read.
                // The process will be repeated until all headers have been parsed from file.

                // Number of 2880 blocks read.  This is reset every time an entire header is extracted.
                this.blockCount = 0;

                // Byte offsets relative to the current header
                this.begin = 0;
                this.end = this.BLOCKLENGTH;

                // Byte offset relative to the file
                this.offset = 0;

                // Initial storage for storing header while parsing.
                this.headerStorage = new Uint8Array();

                // Check the input type for either
                // 1) Path to remote file
                // 2) Native File object
                if (typeof this.arg === 'string') {

                    // Define function at runtime for getting next block
                    this.readNextBlock = this._readBlockFromBuffer;

                    // Get the remote file as an arraybuffer
                    xhr = new XMLHttpRequest();
                    xhr.open('GET', this.arg);
                    xhr.responseType = 'arraybuffer';
                    xhr.onload = () => {

                        // Error handling on the response status
                        if (xhr.status !== 200) {

                            // Execute callback returning a null object on failure
                            this.invoke(this.callback, this.opts);
                            return;
                        }

                        // Get buffer from response
                        this.arg = xhr.response;

                        // Store the buffer byte length
                        this.length = this.arg.byteLength;

                        // Begin reading buffer
                        return this.readFromBuffer();
                    };

                    // Send the request
                    xhr.send();
                } else {
                    // Store the file byte length
                    this.length = this.arg.size;

                    // Define function at runtime for getting next block
                    this.readNextBlock = this._readBlockFromFile;

                    // Get the local file as an arraybuffer
                    this.readFromFile();
                }
            }


            // Interpret an array buffer that is already copied in memory.  Usually
            // used for remote files, though this can be used for local files if
            // the arraybuffer is already in memory.
            readFromBuffer() {
                var block;

                // Get first 2880 block
                block = this.arg.slice(this.begin + this.offset, this.end + this.offset);

                // Begin parsing for headers
                return this.readBlock(block);
            }


            // Read a file by copying only the headers into memory.  This is needed
            // to handle large files efficiently.
            readFromFile() {
                var block;

                // Initialize a new FileReader
                this.reader = new FileReader();

                // Set reader handler
                this.reader.onloadend = (e) => {
                    return this.readBlock(e.target.result);
                };

                // Get first 2880 block
                block = this.arg.slice(this.begin + this.offset, this.end + this.offset);

                // Begin parsing for headers
                return this.reader.readAsArrayBuffer(block);
            }


            // Read a 2880 size block. Function is responsible for storing block,
            // searching for END marker, initializing an HDU, and clearing storage.
            readBlock(block) {
                var arr, dataLength, dataunit, header, j, len, ref, rowIndex, rows, s, slice, tmp, value;

                // Read block as integers
                arr = new Uint8Array(block);

                // Temporary storage for header
                tmp = new Uint8Array(this.headerStorage);

                // Reallocate header storage
                this.headerStorage = new Uint8Array(this.end);

                // Copy contents from temporary storage
                this.headerStorage.set(tmp, 0);

                // Copy contents from current iteration
                this.headerStorage.set(arr, this.begin);

                // Check current array one row at a time starting from
                // bottom of the block.

                rows = this.BLOCKLENGTH / this.LINEWIDTH;
                while (rows--) {

                    // Get index of first element in row
                    rowIndex = rows * this.LINEWIDTH;

                    if (arr[rowIndex] === 32) {

                        // Go to next row if whitespace found
                        continue;
                    }

                    // Check for END keyword with trailing space (69, 78, 68, 32)
                    if (arr[rowIndex] === 69 && arr[rowIndex + 1] === 78 && arr[rowIndex + 2] === 68 && arr[rowIndex + 3] === 32) {

                        // Interpret as string
                        s = '';
                        ref = this.headerStorage;
                        for (j = 0, len = ref.length; j < len; j++) {
                            value = ref[j];
                            s += String.fromCharCode(value);
                        }

                        header = new Header(s);

                        // Get data unit start and length
                        this.start = this.end + this.offset;
                        dataLength = header.getDataLength();

                        // Create data unit instance
                        slice = this.arg.slice(this.start, this.start + dataLength);
                        if (header.hasDataUnit()) {
                            dataunit = this.createDataUnit(header, slice);
                        }

                        // Store HDU on instance
                        this.hdus.push(new HDU(header, dataunit));

                        // Update byte offset
                        this.offset += this.end + dataLength + this.excessBytes(dataLength);

                        // Return if at the end of file
                        if (this.offset === this.length) {
                            this.headerStorage = null;
                            this.invoke(this.callback, this.opts, this);
                            return;
                        }

                        // Reset variables for next header
                        this.blockCount = 0;
                        this.begin = this.blockCount * this.BLOCKLENGTH;
                        this.end = this.begin + this.BLOCKLENGTH;
                        this.headerStorage = new Uint8Array();

                        // Get next block
                        block = this.arg.slice(this.begin + this.offset, this.end + this.offset);

                        // Begin parsing for next header
                        this.readNextBlock(block);
                        return;
                    }

                    break;
                }

                // Read next block since END not found
                this.blockCount += 1;
                this.begin = this.blockCount * this.BLOCKLENGTH;
                this.end = this.begin + this.BLOCKLENGTH;
                block = this.arg.slice(this.begin + this.offset, this.end + this.offset);
                this.readNextBlock(block);
            }


            // Use one of these depending on the initialization parameter (File or ArrayBuffer)
            _readBlockFromBuffer(block) {
                return this.readBlock(block);
            }

            _readBlockFromFile(block) {
                return this.reader.readAsArrayBuffer(block);
            }


            // Create the appropriate data unit based on info from header
            createDataUnit(header, blob) {
                var type;
                type = header.getDataType();
                return new astro.FITS[type](header, blob);
            }


            // Determine the number of characters following a header or data unit
            excessBytes(length) {
                return (this.BLOCKLENGTH - (length % this.BLOCKLENGTH)) % this.BLOCKLENGTH;
            }


            // Check for the end of file
            isEOF() {
                if (this.offset === this.length) {
                    return true;
                } else {
                    return false;
                }
            }

        };

        Parser.prototype.LINEWIDTH = 80;

        Parser.prototype.BLOCKLENGTH = 2880;


        // Prefix function for Safari :(
        File.prototype.slice = File.prototype.slice || File.prototype.webkitSlice;

        Blob.prototype.slice = Blob.prototype.slice || Blob.prototype.webkitSlice;

        return Parser;

    }).call(this);

    FITS = class FITS extends Base {
        constructor(arg, callback, opts) {
            var parser;
            super();
            this.arg = arg;

            parser = new Parser(this.arg, (fits) => {
                this.hdus = parser.hdus;
                return this.invoke(callback, opts, this);
            });

        }


        // Public API

        // Returns the first HDU containing a data unit.  An optional argument may be passed to retreive
        // a specific HDU
        getHDU(index) {
            var hdu, j, len, ref;
            if ((index != null) && (this.hdus[index] != null)) {
                return this.hdus[index];
            }
            ref = this.hdus;
            for (j = 0, len = ref.length; j < len; j++) {
                hdu = ref[j];
                if (hdu.hasData()) {
                    return hdu;
                }
            }
        }

        // Returns the header associated with the first HDU containing a data unit.  An optional argument
        // may be passed to point to a specific HDU.
        getHeader(index) {
            return this.getHDU(index).header;
        }

        // Returns the data object associated with the first HDU containing a data unit.  This method does not read from the array buffer
        // An optional argument may be passed to point to a specific HDU.
        getDataUnit(index) {
            return this.getHDU(index).data;
        }

    };

    FITS.version = '0.6.5';

    this.astro.FITS = FITS;

    Header = (function() {
        // Parse and store a FITS header.  Verification is done for reserved
        // keywords (e.g. SIMPLE, BITPIX, etc).
        class Header extends Base {
            constructor(block) {
                var method, name, ref;
                super();
                this.primary = false;
                this.extension = false;

                // Add verification methods to instance
                this.verifyCard = {};
                ref = this.VerifyFns;
                for (name in ref) {
                    method = ref[name];
                    this.verifyCard[name] = this.proxy(method);
                }

                // e.g. [index, value, comment]
                this.cards = {};
                this.cards["COMMENT"] = [];
                this.cards["HISTORY"] = [];
                this.cardIndex = 0;
                this.block = block;
                this.readBlock(block);
            }


            // Get the value for a key
            get(key) {
                if (this.contains(key)) {
                    return this.cards[key].value;
                } else {
                    return null;
                }
            }


            // Set value to key with optional comment
            set(key, value, comment) {
                comment = comment || '';
                this.cards[key] = {
                    index: this.cardIndex,
                    value: value,
                    comment: comment
                };
                return this.cardIndex += 1;
            }


            // Checks if the header contains a specified keyword
            contains(key) {
                return this.cards.hasOwnProperty(key);
            }

            readLine(l) {
                var blank, comment, firstByte, indicator, key, value;

                // Check bytes 1 to 8 for key or whitespace
                key = l.slice(0, 8).trim();
                blank = key === '';
                if (blank) {
                    return;
                }

                // Get indicator and value
                indicator = l.slice(8, 10);
                value = l.slice(10);

                // Check the indicator
                if (indicator !== "= ") {
                    // Key will be either COMMENT, HISTORY or END
                    // all else is outside the standard.
                    if (key === 'COMMENT' || key === 'HISTORY') {
                        this.cards[key].push(value.trim());
                    }
                    return;
                }

                // Check the value
                [value, comment] = value.split(' /');
                value = value.trim();

                // Values can be a string pattern starting with single quote
                // a boolean pattern (T or F), or a numeric
                firstByte = value[0];
                if (firstByte === "'") {
                    // String data type
                    value = value.slice(1, -1).trim();
                } else {
                    // Boolean or numeric
                    if (value !== 'T' && value !== 'F') {
                        value = parseFloat(value);
                    }
                }
                value = this.validate(key, value);
                return this.set(key, value, comment);
            }

            validate(key, value) {
                var baseKey, index, isArray, match;
                index = null;
                baseKey = key;
                isArray = this.arrayPattern.test(key);
                if (isArray) {
                    match = this.arrayPattern.exec(key);
                    [baseKey, index] = match.slice(1);
                }
                if (baseKey in this.verifyCard) {
                    value = this.verifyCard[baseKey](value, isArray, index);
                }
                return value;
            }

            readBlock(block) {
                var i, j, line, lineWidth, nLines, ref, results;
                lineWidth = 80;
                nLines = block.length / lineWidth;
                nLines = nLines < this.maxLines ? nLines : this.maxLines;
                results = [];
                for (i = j = 0, ref = nLines - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
                    line = block.slice(i * lineWidth, (i + 1) * lineWidth);
                    results.push(this.readLine(line));
                }
                return results;
            }


            // Tells if a data unit follows based on NAXIS
            hasDataUnit() {
                if (this.get("NAXIS") === 0) {
                    return false;
                } else {
                    return true;
                }
            }

            getDataLength() {
                var i, j, length, naxis, ref;
                if (!this.hasDataUnit()) {
                    return 0;
                }
                naxis = [];
                for (i = j = 1, ref = this.get("NAXIS"); (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
                    naxis.push(this.get(`NAXIS${i}`));
                }
                length = naxis.reduce(function(a, b) {
                    return a * b;
                }) * Math.abs(this.get("BITPIX")) / 8;
                length += this.get("PCOUNT");
                return length;
            }


            // Determine the data unit type (e.g IMAGE, BINTABLE, TABLE, COMPRESSED)
            getDataType() {
                switch (this.extensionType) {
                    case 'BINTABLE':
                        if (this.contains('ZIMAGE')) {
                            return 'CompressedImage';
                        }
                        return 'BinaryTable';
                    case 'TABLE':
                        return 'Table';
                    default:
                        if (this.hasDataUnit()) {
                            return 'Image';
                        } else {
                            return null;
                        }
                }
            }


            // Determine type of header
            isPrimary() {
                return this.primary;
            }

            isExtension() {
                return this.extension;
            }

        };

        Header.include(HeaderVerify);

        Header.prototype.arrayPattern = /(\D+)(\d+)/;


        // Headers can become extremely large (for instance after Drizzle). This parameters
        // limits the number of lines that are parsed.  Typically the important information
        // describing the structure of the associated data unit and astrometry are near the
        // top.
        Header.prototype.maxLines = 600;

        return Header;

    }).call(this);

    this.astro.FITS.Header = Header;

    DataUnit = (function() {
        // Base class for FITS data units (e.g. Primary, BINTABLE, TABLE, IMAGE).  Derived classes must
        // define an instance attribute called length describing the byte length of the data unit.
        class DataUnit extends Base {

            // Data units are initialized with the associated header and data that is either
            // 1) ArrayBuffer
            // 2) Blob
            // In the case of the array buffer, the entire file structure is already in memory.
            // The blob has not yet placed the file in memory.
            constructor(header, data) {
                super();
                if (data instanceof ArrayBuffer) {
                    this.buffer = data;
                } else {
                    this.blob = data;
                }
            }

        };


        // Endian swaps are needed for performance.  All FITS images are stored in big
        // endian format, but typed arrays initialize based on the endianness of the CPU (typically little endian).
        // Swaps are triggered to recover the correct values.

        // TODO: Check endianness of client machine by defining a typed array with a known value.
        // Initialize a second typed array using the underlying byte representation.
        // The arrays should be identical if working on a little endian machine.
        // arr = new Uint16Array([524])
        // value = new Uint16Array(arr.buffer)[0]
        // @littleEndian = if value is 524 then true else false
        DataUnit.swapEndian = {
            B: function(value) {
                return value;
            },
            I: function(value) {
                return (value << 8) | (value >> 8);
            },
            J: function(value) {
                return ((value & 0xFF) << 24) | ((value & 0xFF00) << 8) | ((value >> 8) & 0xFF00) | ((value >> 24) & 0xFF);
            }
        };

        DataUnit.swapEndian[8] = DataUnit.swapEndian['B'];

        DataUnit.swapEndian[16] = DataUnit.swapEndian['I'];

        DataUnit.swapEndian[32] = DataUnit.swapEndian['J'];

        return DataUnit;

    }).call(this);

    this.astro.FITS.DataUnit = DataUnit;

    // This module is a collection of function for verifying reserved keywords of the FITS standard
    // When new keywords and extensions are defined, this module may be extended.
    HeaderVerify = {
        verifyOrder: function(keyword, order) {
            if (order !== this.cardIndex) {
                return console.warn(`${keyword} should appear at index ${this.cardIndex} in the FITS header`);
            }
        },
        verifyBetween: function(keyword, value, lower, upper) {
            if (!(value >= lower && value <= upper)) {
                throw `The ${keyword} value of ${value} is not between ${lower} and ${upper}`;
            }
        },
        verifyBoolean: function(value) {
            if (value === "T") {
                return true;
            } else {
                return false;
            }
        },
        VerifyFns: {
            SIMPLE: function(...args) {
                var value;
                value = arguments[0];
                this.primary = true;
                this.verifyOrder("SIMPLE", 0);
                return this.verifyBoolean(value);
            },
            XTENSION: function(...args) {
                this.extension = true;
                this.extensionType = arguments[0];
                this.verifyOrder("XTENSION", 0);
                return this.extensionType;
            },
            BITPIX: function(...args) {
                var key, value;
                key = "BITPIX";
                value = parseInt(arguments[0]);
                this.verifyOrder(key, 1);
                if (value !== 8 && value !== 16 && value !== 32 && value !== (-32) && value !== (-64)) {
                    throw `${key} value ${value} is not permitted`;
                }
                return value;
            },
            NAXIS: function(...args) {
                var array, key, ref, required, value;
                key = "NAXIS";
                value = parseInt(arguments[0]);
                array = arguments[1];
                if (!array) {
                    this.verifyOrder(key, 2);
                    this.verifyBetween(key, value, 0, 999);
                    if (this.isExtension()) {
                        if ((ref = this.extensionType) === "TABLE" || ref === "BINTABLE") {
                            required = 2;
                            if (value !== required) {
                                throw `${key} must be ${required} for TABLE and BINTABLE extensions`;
                            }
                        }
                    }
                }
                return value;
            },
            PCOUNT: function(...args) {
                var key, order, ref, required, value;
                key = "PCOUNT";
                value = parseInt(arguments[0]);
                order = 1 + 1 + 1 + this.get("NAXIS");
                this.verifyOrder(key, order);
                if (this.isExtension()) {
                    if ((ref = this.extensionType) === "IMAGE" || ref === "TABLE") {
                        required = 0;
                        if (value !== required) {
                            throw `${key} must be ${required} for the ${this.extensionType} extensions`;
                        }
                    }
                }
                return value;
            },
            GCOUNT: function(...args) {
                var key, order, ref, required, value;
                key = "GCOUNT";
                value = parseInt(arguments[0]);
                order = 1 + 1 + 1 + this.get("NAXIS") + 1;
                this.verifyOrder(key, order);
                if (this.isExtension()) {
                    if ((ref = this.extensionType) === "IMAGE" || ref === "TABLE" || ref === "BINTABLE") {
                        required = 1;
                        if (value !== required) {
                            throw `${key} must be ${required} for the ${this.extensionType} extensions`;
                        }
                    }
                }
                return value;
            },
            EXTEND: function(...args) {
                var value;
                value = arguments[0];
                if (!this.isPrimary()) {
                    throw "EXTEND must only appear in the primary header";
                }
                return this.verifyBoolean(value);
            },
            BSCALE: function(...args) {
                return parseFloat(arguments[0]);
            },
            BZERO: function(...args) {
                return parseFloat(arguments[0]);
            },
            BLANK: function(...args) {
                var value;
                value = arguments[0];
                if (!(this.get("BITPIX") > 0)) {
                    console.warn(`BLANK is not to be used for BITPIX = ${this.get('BITPIX')}`);
                }
                return parseInt(value);
            },
            DATAMIN: function(...args) {
                return parseFloat(arguments[0]);
            },
            DATAMAX: function(...args) {
                return parseFloat(arguments[0]);
            },
            EXTVER: function(...args) {
                return parseInt(arguments[0]);
            },
            EXTLEVEL: function(...args) {
                return parseInt(arguments[0]);
            },
            TFIELDS: function(...args) {
                var value;
                value = parseInt(arguments[0]);
                this.verifyBetween("TFIELDS", value, 0, 999);
                return value;
            },
            TBCOL: function(...args) {
                var index, value;
                value = arguments[0];
                index = arguments[2];
                this.verifyBetween("TBCOL", index, 0, this.get("TFIELDS"));
                return value;
            },
            ZIMAGE: function(...args) {
                return this.verifyBoolean(arguments[0]);
            },
            ZCMPTYPE: function(...args) {
                var value;
                value = arguments[0];
                if (value !== 'GZIP_1' && value !== 'RICE_1' && value !== 'PLIO_1' && value !== 'HCOMPRESS_1') {
                    throw `ZCMPTYPE value ${value} is not permitted`;
                }
                if (value !== 'RICE_1') {
                    throw `Compress type ${value} is not yet implement`;
                }
                return value;
            },
            ZBITPIX: function(...args) {
                var value;
                value = parseInt(arguments[0]);
                if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {
                    throw `ZBITPIX value ${value} is not permitted`;
                }
                return value;
            },
            ZNAXIS: function(...args) {
                var array, value;
                value = parseInt(arguments[0]);
                array = arguments[1];
                value = value;
                if (!array) {
                    this.verifyBetween("ZNAXIS", value, 0, 999);
                }
                return value;
            },
            ZTILE: function(...args) {
                return parseInt(arguments[0]);
            },
            ZSIMPLE: function(...args) {
                if (arguments[0] === "T") {
                    return true;
                } else {
                    return false;
                }
            },
            ZPCOUNT: function(...args) {
                return parseInt(arguments[0]);
            },
            ZGCOUNT: function(...args) {
                return parseInt(arguments[0]);
            },
            ZDITHER0: function(...args) {
                return parseInt(arguments[0]);
            }
        }
    };

    this.astro.FITS.HeaderVerify = HeaderVerify;



    ImageUtils = {

        // Compute the minimum and maximum pixels
        getExtent: function(arr) {
            var index, max, min, value;

            // Set initial values for min and max
            index = arr.length;
            while (index--) {
                value = arr[index];
                if (isNaN(value)) {
                    continue;
                }
                min = max = value;
                break;
            }
            if (index === -1) {
                return [0/0, 0/0];
            }

            // Continue loop to find extent
            while (index--) {
                value = arr[index];
                if (isNaN(value)) {
                    continue;
                }
                if (value < min) {
                    min = value;
                }
                if (value > max) {
                    max = value;
                }
            }
            return [min, max];
        },
        getPixel: function(arr, x, y) {
            return arr[y * this.width + x];
        }
    };

    this.astro.FITS.ImageUtils = ImageUtils;

    Image = (function() {
        // Image represents a standard image stored in the data unit of a FITS file
        class Image extends DataUnit {
            constructor(header, data) {
                var begin, frame, i, j, n, naxis, ref, ref1;
                super(header, data);

                // Get parameters from header
                naxis = header.get("NAXIS");
                this.bitpix = header.get("BITPIX");
                this.naxis = [];
                for (i = j = 1, ref = naxis; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
                    this.naxis.push(header.get(`NAXIS${i}`));
                }
                this.width = header.get("NAXIS1");
                this.height = header.get("NAXIS2") || 1;
                this.depth = header.get("NAXIS3") || 1;
                this.bzero = header.get("BZERO") || 0;
                this.bscale = header.get("BSCALE") || 1;
                this.bytes = Math.abs(this.bitpix) / 8;
                this.length = this.naxis.reduce(function(a, b) {
                    return a * b;
                }) * Math.abs(this.bitpix) / 8;
                this.frame = 0; // Needed for data cubes

                // Create a look up table to store byte offsets for each frame
                // in the image.  This is mostly relevant to data cubes.  Each entry stores
                // the beginning offset of a frame.  A frame length parameter stores the byte
                // length of a single frame.
                this.frameOffsets = [];
                this.frameLength = this.bytes * this.width * this.height;

                // Set number of buffers per frame
                this.nBuffers = this.buffer != null ? 1 : 2;
                for (i = n = 0, ref1 = this.depth - 1; (0 <= ref1 ? n <= ref1 : n >= ref1); i = 0 <= ref1 ? ++n : --n) {
                    begin = i * this.frameLength;
                    frame = {
                        begin: begin
                    };
                    if (this.buffer != null) {
                        frame.buffers = [this.buffer.slice(begin, begin + this.frameLength)];
                    }
                    this.frameOffsets.push(frame);
                }
            }


            // Shared method for Image class and also for Web Worker.  Cannot reference any instance variables
            // This is an internal function that converts bytes to pixel values.  There is no reference to instance
            // variables in this function because it is executed on a Web Worker, which always exists outside the
            // scope of this function (class).
            _getFrame(buffer, bitpix, bzero, bscale) {
                var arr, bytes, dataType, i, nPixels, swapEndian, tmp, value;

                // Get the number of pixels represented in buffer
                bytes = Math.abs(bitpix) / 8;
                nPixels = i = buffer.byteLength / bytes;
                dataType = Math.abs(bitpix);
                if (bitpix > 0) {
                    switch (bitpix) {
                        case 8:
                            tmp = new Uint8Array(buffer);
                            tmp = new Uint16Array(tmp);
                            swapEndian = function(value) {
                                return value;
                            };
                            break;
                        case 16:
                            tmp = new Int16Array(buffer);
                            swapEndian = function(value) {
                                return ((value & 0xFF) << 8) | ((value >> 8) & 0xFF);
                            };
                            break;
                        case 32:
                            tmp = new Int32Array(buffer);
                            swapEndian = function(value) {
                                return ((value & 0xFF) << 24) | ((value & 0xFF00) << 8) | ((value >> 8) & 0xFF00) | ((value >> 24) & 0xFF);
                            };
                    }

                    // Patch for data unit with BSCALE AND BZERO ...
                    if (!(parseInt(bzero) === bzero && parseInt(bscale) === bscale)) {
                        arr = new Float32Array(tmp.length);
                    } else {
                        arr = tmp;
                    }
                    while (nPixels--) {

                        // Swap endian and recast into typed array (needed to properly handle any overflow)
                        tmp[nPixels] = swapEndian(tmp[nPixels]);
                        arr[nPixels] = bzero + bscale * tmp[nPixels];
                    }
                } else {
                    arr = new Uint32Array(buffer);
                    swapEndian = function(value) {
                        return ((value & 0xFF) << 24) | ((value & 0xFF00) << 8) | ((value >> 8) & 0xFF00) | ((value >> 24) & 0xFF);
                    };
                    while (i--) {
                        value = arr[i];
                        arr[i] = swapEndian(value);
                    }

                    // Initialize a Float32 array using the same buffer
                    arr = new Float32Array(buffer);

                    // Apply BZERO and BSCALE
                    while (nPixels--) {
                        arr[nPixels] = bzero + bscale * arr[nPixels];
                    }
                }
                return arr;
            }

            _getFrameAsync(buffers, callback, opts) {
                var URL, blobGetFrame, blobOnMessage, fn1, fn2, i, mime, msg, onmessage, pixels, start, urlGetFrame, urlOnMessage, worker;

                // Define function to be executed on the worker thread
                onmessage = function(e) {
                    var arr, bitpix, bscale, buffer, bzero, data, url;
                    // Get variables sent from main thread
                    data = e.data;
                    buffer = data.buffer;
                    bitpix = data.bitpix;
                    bzero = data.bzero;
                    bscale = data.bscale;
                    url = data.url;

                    // Import getFrame function
                    importScripts(url);
                    arr = _getFrame(buffer, bitpix, bzero, bscale);
                    return postMessage(arr);
                };

                // Trick to format function for worker
                fn1 = onmessage.toString().replace('return postMessage', 'postMessage');
                fn1 = `onmessage = ${fn1}`;

                // Functions passed to worker via url cannot be anonymous
                fn2 = this._getFrame.toString();
                fn2 = fn2.replace('function', 'function _getFrame');

                // Construct blob for an inline worker and _getFrame function
                mime = "application/javascript";
                blobOnMessage = new Blob([fn1], {
                    type: mime
                });
                blobGetFrame = new Blob([fn2], {
                    type: mime
                });

                // Create URLs to onmessage and _getFrame scripts
                URL = window.URL || window.webkitURL; // to appease Safari
                urlOnMessage = URL.createObjectURL(blobOnMessage);
                urlGetFrame = URL.createObjectURL(blobGetFrame);

                // Initialize worker
                worker = new Worker(urlOnMessage);

                // Define object containing parameters to be passed to worker beginning with first buffer
                msg = {
                    buffer: buffers[0],
                    bitpix: this.bitpix,
                    bzero: this.bzero,
                    bscale: this.bscale,
                    url: urlGetFrame
                };

                // Define function for when worker job is complete
                i = 0;
                pixels = null;
                start = 0;
                worker.onmessage = (e) => {
                    var arr;
                    arr = e.data;

                    // Initialize storage for all pixels
                    if (pixels == null) {
                        pixels = new arr.constructor(this.width * this.height);
                    }
                    pixels.set(arr, start);

                    // Set start index for next iteration
                    start += arr.length;
                    i += 1;
                    if (i === this.nBuffers) {
                        this.invoke(callback, opts, pixels);

                        // Clean up urls and worker
                        URL.revokeObjectURL(urlOnMessage);
                        URL.revokeObjectURL(urlGetFrame);
                        return worker.terminate();
                    } else {
                        msg.buffer = buffers[i];
                        return worker.postMessage(msg, [buffers[i]]);
                    }
                };
                worker.postMessage(msg, [buffers[0]]);
            }


            // Read frames from image.  Frames are read sequentially unless nFrame is set.
            // A callback must be provided since there are 1 or more asynchronous processes happening
            // to convert bytes to flux. This is a case where a partially synchronous and
            // completely asynchronous process are abstracted by a single function.
            getFrame(frame, callback, opts) {
                var begin, blobFrame, blobs, buffers, bytesPerBuffer, frameInfo, i, j, nRowsPerBuffer, reader, ref, start;
                this.frame = frame || this.frame;
                frameInfo = this.frameOffsets[this.frame];
                buffers = frameInfo.buffers;

                // Check if bytes are in memory
                if ((buffers != null ? buffers.length : void 0) === this.nBuffers) {
                    return this._getFrameAsync(buffers, callback, opts);
                } else {

                    // Read frame bytes into memory incrementally
                    this.frameOffsets[this.frame].buffers = [];

                    // Slice blob for only current frame bytes
                    begin = frameInfo.begin;
                    blobFrame = this.blob.slice(begin, begin + this.frameLength);

                    // Slice blob into chunks to prevent reading too much data in single operation
                    blobs = [];
                    nRowsPerBuffer = Math.floor(this.height / this.nBuffers);
                    bytesPerBuffer = nRowsPerBuffer * this.bytes * this.width;
                    for (i = j = 0, ref = this.nBuffers - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
                        start = i * bytesPerBuffer;
                        if (i === this.nBuffers - 1) {
                            blobs.push(blobFrame.slice(start));
                        } else {
                            blobs.push(blobFrame.slice(start, start + bytesPerBuffer));
                        }
                    }

                    // Create array for buffers
                    buffers = [];

                    // Create file reader and store frame number on object for later reference
                    reader = new FileReader();
                    reader.frame = this.frame;
                    i = 0;
                    reader.onloadend = (e) => {
                        var buffer;
                        frame = e.target.frame;
                        buffer = e.target.result;

                        // Store the buffer for later access
                        this.frameOffsets[frame].buffers.push(buffer);
                        i += 1;
                        if (i === this.nBuffers) {
                            // Call function again
                            return this.getFrame(frame, callback, opts);
                        } else {
                            return reader.readAsArrayBuffer(blobs[i]);
                        }
                    };
                    return reader.readAsArrayBuffer(blobs[0]);
                }
            }


            // Reads frames in a data cube in an efficient way that does not
            // overload the browser. The callback passed will be executed once for
            // each frame, in the sequential order of the cube.
            getFrames(frame, number, callback, opts) {
                var cb;

                // Define callback to pass to getFrame
                cb = (arr, opts) => {
                    this.invoke(callback, opts, arr);

                    // Update counters
                    number -= 1;
                    frame += 1;
                    if (!number) {
                        return;
                    }

                    // Request another frame
                    return this.getFrame(frame, cb, opts);
                };

                // Start reading frames
                return this.getFrame(frame, cb, opts);
            }


            // Checks if the image is a data cube
            isDataCube() {
                if (this.naxis.length > 2) {
                    return true;
                } else {
                    return false;
                }
            }

        };

        Image.include(ImageUtils);


        // When reading from a File object, only needed portions of file are placed into memory.
        // When large heaps are required, they are requested in 16 MB increments.
        Image.prototype.allocationSize = 16777216;

        return Image;

    }).call(this);

    this.astro.FITS.Image = Image;

    Tabular = (function() {

        // Abstract class for tabular FITS extensions (e.g. TABLE, BINTABLE)
        class Tabular extends DataUnit {
            constructor(header, data) {
                super(header, data);
                this.rowByteSize = header.get("NAXIS1");
                this.rows = header.get("NAXIS2");
                this.cols = header.get("TFIELDS");

                // Get bytes size of the data unit and column names
                this.length = this.rowByteSize * this.rows;
                this.heapLength = header.get("PCOUNT");
                this.columns = this.getColumns(header);

                // Store information about the buffer
                if (this.buffer != null) {

                    // Define function at run time that checks if row is in memory
                    this.rowsInMemory = this._rowsInMemoryBuffer;

                    // Keep separate buffer for heap
                    // NOTE: This causes a duplication of the buffer in memory. Find better solution.
                    this.heap = this.buffer.slice(this.length, this.length + this.heapLength);
                } else {
                    this.rowsInMemory = this._rowsInMemoryBlob;

                    // No rows are in memory
                    this.firstRowInBuffer = this.lastRowInBuffer = 0;

                    // Use maxMemory to get the number of rows to hold in memory
                    this.nRowsInBuffer = Math.floor(this.maxMemory / this.rowByteSize);
                }

                // Storage for accessor functions, descriptors and offsets for each column
                this.accessors = [];
                this.descriptors = [];
                this.elementByteLengths = [];
                this.setAccessors(header);
            }


            // Determine if the row is in memory. For tables initialized with an array buffer, all rows
            // are in memory, so there is no need to check. For tables initialized with a blob, this check
            // is needed to determine if the file needs to be read before accessing data.
            _rowsInMemoryBuffer() {
                return true;
            }

            _rowsInMemoryBlob(firstRow, lastRow) {
                if (firstRow < this.firstRowInBuffer) {
                    return false;
                }
                if (lastRow > this.lastRowInBuffer) {
                    return false;
                }
                return true;
            }

            // Get the column names from the header
            getColumns(header) {
                var columns, i, j, key, ref;
                columns = [];
                for (i = j = 1, ref = this.cols; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
                    key = `TTYPE${i}`;
                    if (!header.contains(key)) {
                        return null;
                    }
                    columns.push(header.get(key));
                }
                return columns;
            }


            // Get column of data specified by parameters.
            getColumn(name, callback, opts) {
                var accessor, cb, column, descriptor, elementByteLength, elementByteOffset, factor, i, index, iterations, rowsPerIteration;
                // Check for blob
                if (this.blob != null) {

                    // Storage for column using typed array when able
                    index = this.columns.indexOf(name);
                    descriptor = this.descriptors[index];
                    accessor = this.accessors[index];
                    elementByteLength = this.elementByteLengths[index];
                    elementByteOffset = this.elementByteLengths.slice(0, index);
                    if (elementByteOffset.length === 0) {
                        elementByteOffset = 0;
                    } else {
                        elementByteOffset = elementByteOffset.reduce(function(a, b) {
                            return a + b;
                        });
                    }
                    column = this.typedArray[descriptor] != null ? new this.typedArray[descriptor](this.rows) : [];

                    // Read rows in ~8 MB chunks
                    rowsPerIteration = ~~(this.maxMemory / this.rowByteSize);
                    rowsPerIteration = Math.min(rowsPerIteration, this.rows);

                    // Get number of iterations needed to read entire file
                    factor = this.rows / rowsPerIteration;
                    iterations = Math.floor(factor) === factor ? factor : Math.floor(factor) + 1;
                    i = 0;
                    index = 0;

                    // Define callback to pass to getRows
                    cb = (buffer, opts) => {
                        var nRows, offset, startRow, view;
                        nRows = buffer.byteLength / this.rowByteSize;
                        view = new DataView(buffer);
                        offset = elementByteOffset;

                        // Read only the column value from the buffer
                        while (nRows--) {
                            column[i] = accessor(view, offset)[0];
                            i += 1;
                            offset += this.rowByteSize;
                        }

                        // Update counters
                        iterations -= 1;
                        index += 1;

                        // Request another buffer of rows
                        if (iterations) {
                            startRow = index * rowsPerIteration;
                            return this.getTableBuffer(startRow, rowsPerIteration, cb, opts);
                        } else {
                            this.invoke(callback, opts, column);
                        }
                    };

                    // Start reading rows
                    return this.getTableBuffer(0, rowsPerIteration, cb, opts);
                } else {
                    // Table already in memory.  Get column using getRows method
                    cb = (rows, opts) => {
                        column = rows.map(function(d) {
                            return d[name];
                        });
                        return this.invoke(callback, opts, column);
                    };
                    return this.getRows(0, this.rows, cb, opts);
                }
            }


            // Get buffer representing a number of rows. The resulting buffer
            // should be passed to another function for either row or column access.
            // NOTE: Using only for local files that are not in memory.
            getTableBuffer(row, number, callback, opts) {
                var begin, blobRows, end, reader;

                // Get the number of remaining rows
                number = Math.min(this.rows - row, number);

                // Get the offsets to slice the blob. Note the API allows for more memory to be allocated
                // by the developer if the number of rows is greater than the default heap size.
                begin = row * this.rowByteSize;
                end = begin + number * this.rowByteSize;

                // Slice blob for only relevant bytes
                blobRows = this.blob.slice(begin, end);

                // Create file reader and store row and number on object for later reference
                reader = new FileReader();
                reader.row = row;
                reader.number = number;
                reader.onloadend = (e) => {
                    // Pass arraybuffer to a parser function via callback
                    return this.invoke(callback, opts, e.target.result);
                };
                return reader.readAsArrayBuffer(blobRows);
            }


            // Get rows of data specified by parameters.  In the case where
            // the data is not yet in memory, a callback must be provided to
            // expose the results. This is due to the asynchonous reading of
            // the file.
            getRows(row, number, callback, opts) {
                var begin, blobRows, buffer, end, reader, rows;

                // Check if rows are in memory
                if (this.rowsInMemory(row, row + number)) {

                    // Buffer needs slicing if entire file is in memory
                    if (this.blob != null) {
                        buffer = this.buffer;
                    } else {
                        begin = row * this.rowByteSize;
                        end = begin + number * this.rowByteSize;
                        buffer = this.buffer.slice(begin, end);
                    }

                    // Derived classes must implement this function
                    rows = this._getRows(buffer, number);
                    this.invoke(callback, opts, rows);
                    return rows;
                } else {

                    // Get the offsets to slice the blob. Note the API allows for more memory to be allocated
                    // by the developer if the number of rows is greater than the default heap size.
                    begin = row * this.rowByteSize;
                    end = begin + Math.max(this.nRowsInBuffer * this.rowByteSize, number * this.rowByteSize);

                    // Slice blob for only bytes
                    blobRows = this.blob.slice(begin, end);

                    // Create file reader and store row and number on object for later reference
                    reader = new FileReader();
                    reader.row = row;
                    reader.number = number;
                    reader.onloadend = (e) => {
                        var target;
                        target = e.target;

                        // Store the array buffer on the object
                        // TODO: Double check this as it might result in failure to GC
                        this.buffer = target.result;
                        this.firstRowInBuffer = this.lastRowInBuffer = target.row;
                        this.lastRowInBuffer += target.number;

                        // Call function again
                        return this.getRows(row, number, callback, opts);
                    };
                    return reader.readAsArrayBuffer(blobRows);
                }
            }

        };


        // The maximum amount of memory to hold on object when
        // reading a local file. 8 MBs.
        // maxMemory: 8388608
        Tabular.prototype.maxMemory = 1048576;

        return Tabular;

    }).call(this);

    this.astro.FITS.Tabular = Tabular;

    Table = (function() {
        // Class to read ASCII tables from FITS files.
        class Table extends Tabular {
            setAccessors(header) {
                var descriptor, form, i, j, match, pattern, ref, results, type;
                pattern = /([AIFED])(\d+)\.*(\d+)*/;
                results = [];
                for (i = j = 1, ref = this.cols; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
                    form = header.get(`TFORM${i}`);
                    type = header.get(`TTYPE${i}`);
                    match = pattern.exec(form);
                    descriptor = match[1];
                    results.push(((descriptor) => {
                        var accessor;
                        accessor = (value) => {
                            return this.dataAccessors[descriptor](value);
                        };
                        return this.accessors.push(accessor);
                    })(descriptor));
                }
                return results;
            }

            _getRows(buffer) {
                var accessor, arr, begin, end, i, index, j, len, len1, line, n, nRows, o, ref, ref1, row, rows, subarray, value;

                // Get the number of rows in buffer
                nRows = buffer.byteLength / this.rowByteSize;

                // Interpret the buffer
                arr = new Uint8Array(buffer);

                // Storage for rows
                rows = [];

                // Loop over the number of rows
                for (i = j = 0, ref = nRows - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {

                    // Get the subarray for current row
                    begin = i * this.rowByteSize;
                    end = begin + this.rowByteSize;
                    subarray = arr.subarray(begin, end);

                    // Convert to string representation
                    line = '';
                    for (n = 0, len = subarray.length; n < len; n++) {
                        value = subarray[n];
                        line += String.fromCharCode(value);
                    }
                    line = line.trim().split(/\s+/);

                    // Storage for current row
                    row = {};
                    ref1 = this.accessors;

                    // Convert to correct data type using accessor functions
                    for (index = o = 0, len1 = ref1.length; o < len1; index = ++o) {
                        accessor = ref1[index];
                        value = line[index];
                        row[this.columns[index]] = accessor(value);
                    }

                    // Store row on array
                    rows.push(row);
                }
                return rows;
            }

        };


        // Define functions for parsing ASCII entries
        Table.prototype.dataAccessors = {
            A: function(value) {
                return value.trim();
            },
            I: function(value) {
                return parseInt(value);
            },
            F: function(value) {
                return parseFloat(value);
            },
            E: function(value) {
                return parseFloat(value);
            },
            D: function(value) {
                return parseFloat(value);
            }
        };

        return Table;

    }).call(this);

    this.astro.FITS.Table = Table;

    BinaryTable = (function() {
        class BinaryTable extends Tabular {
            toBits(byte) {
                var arr, i;
                arr = [];
                i = 128;
                while (i >= 1) {
                    arr.push((byte & i ? 1 : 0));
                    i /= 2;
                }
                return arr;
            }


            // Get bytes from the heap that follows the main data structure.  Often used
            // for binary tables and compressed images.
            getFromHeap(view, offset, descriptor) {
                var arr, heapOffset, heapSlice, i, length;

                // Get length and offset of the heap
                length = view.getInt32(offset);
                offset += 4;
                heapOffset = view.getInt32(offset);
                offset += 4;

                // Read from the buffer
                heapSlice = this.heap.slice(heapOffset, heapOffset + length);
                arr = new this.typedArray[descriptor](heapSlice);

                // TODO: Make conditional on array type (e.g. byte arrays do not need endian swap)
                // Swap endian
                i = arr.length;
                while (i--) {
                    arr[i] = this.constructor.swapEndian[descriptor](arr[i]);
                }
                return [arr, offset];
            }

            setAccessors(header) {
                var count, descriptor, form, i, isArray, j, match, pattern, ref, results, type;
                pattern = /(\d*)([P|Q]*)([L|X|B|I|J|K|A|E|D|C|M]{1})/;
                results = [];
                for (i = j = 1, ref = this.cols; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
                    form = header.get(`TFORM${i}`);
                    type = header.get(`TTYPE${i}`);
                    match = pattern.exec(form);
                    count = parseInt(match[1]) || 1;
                    isArray = match[2];
                    descriptor = match[3];
                    results.push(((descriptor, count) => {
                        var accessor, nBytes;

                        // Store the descriptor for each column
                        this.descriptors.push(descriptor);

                        // Store the offset for each column
                        this.elementByteLengths.push(this.constructor.offsets[descriptor] * count);
                        if (isArray) {

                            // Handle array descriptors
                            switch (type) {
                                case "COMPRESSED_DATA":
                                    accessor = (view, offset) => {
                                        var arr, pixels;
                                        [arr, offset] = this.getFromHeap(view, offset, descriptor);

                                        // Assuming Rice compression
                                        pixels = new this.typedArray[this.algorithmParameters["BYTEPIX"]](this.ztile[0]);
                                        Decompress.Rice(arr, this.algorithmParameters["BLOCKSIZE"], this.algorithmParameters["BYTEPIX"], pixels, this.ztile[0], Decompress.RiceSetup);
                                        return [pixels, offset];
                                    };
                                    break;
                                case "GZIP_COMPRESSED_DATA":

                                    // TODO: Implement GZIP using https://github.com/imaya/zlib.js
                                    accessor = (view, offset) => {
                                        var arr;
                                        // [arr, offset] = @getFromHeap(view, offset, descriptor)

                                        // Temporarily padding with NaNs until GZIP is implemented
                                        arr = new Float32Array(this.width);
                                        i = arr.length;
                                        while (i--) {
                                            arr[i] = 0/0;
                                        }
                                        return [arr, offset];
                                    };
                                    break;
                                default:
                                    accessor = (view, offset) => {
                                        return this.getFromHeap(view, offset, descriptor);
                                    };
                            }
                        } else {
                            if (count === 1) {

                                // Handle single element
                                accessor = (view, offset) => {
                                    var value;
                                    [value, offset] = this.dataAccessors[descriptor](view, offset);
                                    return [value, offset];
                                };
                            } else {

                                // Handle bit arrays
                                if (descriptor === 'X') {
                                    nBytes = Math.log(count) / Math.log(2);
                                    accessor = (view, offset) => {
                                        var arr, bits, buffer, byte, bytes, len, n;

                                        // Read from buffer
                                        buffer = view.buffer.slice(offset, offset + nBytes);
                                        bytes = new Uint8Array(buffer);

                                        // Get bit representation
                                        bits = [];
                                        for (n = 0, len = bytes.length; n < len; n++) {
                                            byte = bytes[n];
                                            arr = this.toBits(byte);
                                            bits = bits.concat(arr);
                                        }

                                        // Increment the offset
                                        offset += nBytes;
                                        return [bits.slice(0, +(count - 1) + 1 || 9e9), offset];
                                    };

                                    // Handle character arrays
                                } else if (descriptor === 'A') {
                                    accessor = (view, offset) => {
                                        var arr, buffer, len, n, s, value;

                                        // Read from buffer
                                        buffer = view.buffer.slice(offset, offset + count);
                                        arr = new Uint8Array(buffer);
                                        s = '';
                                        for (n = 0, len = arr.length; n < len; n++) {
                                            value = arr[n];
                                            s += String.fromCharCode(value);
                                        }
                                        s = s.trim();

                                        // Increment offset
                                        offset += count;
                                        return [s, offset];
                                    };
                                } else {

                                    // Handle all other data types
                                    accessor = (view, offset) => {
                                        var data, value;
                                        i = count;
                                        data = [];
                                        while (i--) {
                                            [value, offset] = this.dataAccessors[descriptor](view, offset);
                                            data.push(value);
                                        }
                                        return [data, offset];
                                    };
                                }
                            }
                        }

                        // Push accessor function to array
                        return this.accessors.push(accessor);
                    })(descriptor, count));
                }
                return results;
            }

            _getRows(buffer, nRows) {
                var accessor, index, j, len, offset, ref, row, rows, value, view;

                // Set up view and offset
                view = new DataView(buffer);
                offset = 0;

                // Storage for rows
                rows = [];

                // Read each row
                while (nRows--) {

                    // Storage for current row
                    row = {};
                    ref = this.accessors;
                    for (index = j = 0, len = ref.length; j < len; index = ++j) {
                        accessor = ref[index];

                        // Read value from each column in current row
                        [value, offset] = accessor(view, offset);
                        row[this.columns[index]] = value;
                    }

                    // Store row on array
                    rows.push(row);
                }
                return rows;
            }

        };


        // Look up table for matching appropriate typed array
        BinaryTable.prototype.typedArray = {
            B: Uint8Array,
            I: Uint16Array,
            J: Uint32Array,
            E: Float32Array,
            D: Float64Array,
            1: Uint8Array,
            2: Uint16Array,
            4: Uint32Array
        };

        BinaryTable.offsets = {
            L: 1,
            B: 1,
            I: 2,
            J: 4,
            K: 8,
            A: 1,
            E: 4,
            D: 8,
            C: 8,
            M: 16
        };


        // Define functions for parsing binary tables.
        // NOTE: Accessor function for bit array is better implemented in another function below
        BinaryTable.prototype.dataAccessors = {
            L: function(view, offset) {
                var val, x;
                x = view.getInt8(offset);
                offset += 1;
                val = x === 84 ? true : false;
                return [val, offset];
            },
            B: function(view, offset) {
                var val;
                val = view.getUint8(offset);
                offset += 1;
                return [val, offset];
            },
            I: function(view, offset) {
                var val;
                val = view.getInt16(offset);
                offset += 2;
                return [val, offset];
            },
            J: function(view, offset) {
                var val;
                val = view.getInt32(offset);
                offset += 4;
                return [val, offset];
            },
            K: function(view, offset) {
                var factor, highByte, lowByte, mod, val;
                highByte = Math.abs(view.getInt32(offset));
                offset += 4;
                lowByte = Math.abs(view.getInt32(offset));
                offset += 4;
                mod = highByte % 10;
                factor = mod ? -1 : 1;
                highByte -= mod;
                val = factor * ((highByte << 32) | lowByte);
                return [val, offset];
            },
            A: function(view, offset) {
                var val;
                val = view.getUint8(offset);
                val = String.fromCharCode(val);
                offset += 1;
                return [val, offset];
            },
            E: function(view, offset) {
                var val;
                val = view.getFloat32(offset);
                offset += 4;
                return [val, offset];
            },
            D: function(view, offset) {
                var val;
                val = view.getFloat64(offset);
                offset += 8;
                return [val, offset];
            },
            C: function(view, offset) {
                var val, val1, val2;
                val1 = view.getFloat32(offset);
                offset += 4;
                val2 = view.getFloat32(offset);
                offset += 4;
                val = [val1, val2];
                return [val, offset];
            },
            M: function(view, offset) {
                var val, val1, val2;
                val1 = view.getFloat64(offset);
                offset += 8;
                val2 = view.getFloat64(offset);
                offset += 8;
                val = [val1, val2];
                return [val, offset];
            }
        };

        return BinaryTable;

    }).call(this);

    this.astro.FITS.BinaryTable = BinaryTable;

    // # Decompress

    // Module will contain various decompression algorithms used in compressing FITS images.  Currently only
    // the Rice decompression algorithm is implemented.  The four adopted algorithms are:

    // * Rice
    // * Gzip
    // * IRAF PLIO
    // * H-Compress
    Decompress = {
        RiceSetup: {
            // Set up for bytepix = 1
            1: function(array) {
                var fsbits, fsmax, lastpix, pointer;
                pointer = 1;
                fsbits = 3;
                fsmax = 6;
                lastpix = array[0];
                return [fsbits, fsmax, lastpix, pointer];
            },

            // Set up for bytepix = 2
            2: function(array) {
                var bytevalue, fsbits, fsmax, lastpix, pointer;
                pointer = 2;
                fsbits = 4;
                fsmax = 14;
                lastpix = 0;
                bytevalue = array[0];
                lastpix = lastpix | (bytevalue << 8);
                bytevalue = array[1];
                lastpix = lastpix | bytevalue;
                return [fsbits, fsmax, lastpix, pointer];
            },

            // Set up for bytepix = 4
            4: function(array) {
                var bytevalue, fsbits, fsmax, lastpix, pointer;
                pointer = 4;
                fsbits = 5;
                fsmax = 25;
                lastpix = 0;
                bytevalue = array[0];
                lastpix = lastpix | (bytevalue << 24);
                bytevalue = array[1];
                lastpix = lastpix | (bytevalue << 16);
                bytevalue = array[2];
                lastpix = lastpix | (bytevalue << 8);
                bytevalue = array[3];
                lastpix = lastpix | bytevalue;
                return [fsbits, fsmax, lastpix, pointer];
            }
        },

        // ### Rice
        // * array: Array of compressed bytes to be decompressed
        // * blocksize: Number of pixels encoded in a block
        // * bytepix: Number of 8-bit bytes of the original integer pixel
        // * pixels: Output array containing the decompressed values
        // * nx: Length of pixels (ztile1)
        Rice: function(array, blocksize, bytepix, pixels, nx, setup) {
            var b, bbits, diff, fs, fsbits, fsmax, i, imax, k, lastpix, nbits, nonzeroCount, nzero, pointer;
            bbits = 1 << fsbits;
            [fsbits, fsmax, lastpix, pointer] = setup[bytepix](array);
            nonzeroCount = new Uint8Array(256);
            nzero = 8;
            [k, i] = [128, 255];
            while (i >= 0) {
                while (i >= k) {
                    nonzeroCount[i] = nzero;
                    i -= 1;
                }
                k = k / 2;
                nzero -= 1;
            }
            nonzeroCount[0] = 0;

            // Bit buffer
            b = array[pointer++];

            // Number of bits remaining in b
            nbits = 8;
            i = 0;
            while (i < nx) {
                nbits -= fsbits;
                while (nbits < 0) {
                    b = (b << 8) | array[pointer++];
                    nbits += 8;
                }
                fs = (b >> nbits) - 1;
                b &= (1 << nbits) - 1;
                imax = i + blocksize;
                if (imax > nx) {
                    imax = nx;
                }
                if (fs < 0) {
                    while (i < imax) {
                        pixels[i] = lastpix;
                        i += 1;
                    }
                } else if (fs === fsmax) {
                    while (i < imax) {
                        k = bbits - nbits;
                        diff = b << k;
                        k -= 8;
                        while (k >= 0) {
                            b = array[pointer++];
                            diff |= b << k;
                            k -= 8;
                        }
                        if (nbits > 0) {
                            b = array[pointer++];
                            diff |= b >> (-k);
                            b &= (1 << nbits) - 1;
                        } else {
                            b = 0;
                        }
                        if ((diff & 1) === 0) {
                            diff = diff >> 1;
                        } else {
                            diff = ~(diff >> 1);
                        }
                        pixels[i] = diff + lastpix;
                        lastpix = pixels[i];
                        i++;
                    }
                } else {
                    while (i < imax) {
                        while (b === 0) {
                            nbits += 8;
                            b = array[pointer++];
                        }
                        nzero = nbits - nonzeroCount[b];
                        nbits -= nzero + 1;
                        b ^= 1 << nbits;
                        nbits -= fs;
                        while (nbits < 0) {
                            b = (b << 8) | array[pointer++];
                            nbits += 8;
                        }
                        diff = (nzero << fs) | (b >> nbits);
                        b &= (1 << nbits) - 1;
                        if ((diff & 1) === 0) {
                            diff = diff >> 1;
                        } else {
                            diff = ~(diff >> 1);
                        }
                        pixels[i] = diff + lastpix;
                        lastpix = pixels[i];
                        i++;
                    }
                }
            }
            return pixels;
        }
    };

    this.astro.FITS.Decompress = Decompress;

    CompressedImage = (function() {
        class CompressedImage extends BinaryTable {

            // Predefined random number generator from http://arxiv.org/pdf/1201.1336v1.pdf
            // This is the same method used by fpack when dithering images during compression.
            static randomGenerator() {
                var a, i, j, m, random, seed, temp;
                a = 16807;
                m = 2147483647;
                seed = 1;
                random = new Float32Array(10000);
                for (i = j = 0; j <= 9999; i = ++j) {
                    temp = a * seed;
                    seed = temp - m * parseInt(temp / m);
                    random[i] = seed / m;
                }
                return random;
            }

            constructor(header, data) {
                var i, j, key, ref, value, ztile;
                super(header, data);

                // Get compression values
                this.zcmptype = header.get("ZCMPTYPE");
                this.zbitpix = header.get("ZBITPIX");
                this.znaxis = header.get("ZNAXIS");
                this.zblank = header.get("ZBLANK");
                this.blank = header.get("BLANK");
                this.zdither = header.get('ZDITHER0') || 0;
                this.ztile = [];
                for (i = j = 1, ref = this.znaxis; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
                    ztile = header.contains(`ZTILE${i}`) ? header.get(`ZTILE${i}`) : i === 1 ? header.get("ZNAXIS1") : 1;
                    this.ztile.push(ztile);
                }
                this.width = header.get("ZNAXIS1");
                this.height = header.get("ZNAXIS2") || 1;

                // Storage for compression algorithm parameters
                this.algorithmParameters = {};

                // Set default parameters
                if (this.zcmptype === 'RICE_1') {
                    this.algorithmParameters["BLOCKSIZE"] = 32;
                    this.algorithmParameters["BYTEPIX"] = 4;
                }

                // Get compression algorithm parameters (override defaults when keys present)
                i = 1;
                while (true) {
                    key = `ZNAME${i}`;
                    if (!header.contains(key)) {
                        break;
                    }
                    value = `ZVAL${i}`;
                    this.algorithmParameters[header.get(key)] = header.get(value);
                    i += 1;
                }
                this.zmaskcmp = header.get("ZMASKCMP");
                this.zquantiz = header.get("ZQUANTIZ") || "LINEAR_SCALING";
                this.bzero = header.get("BZERO") || 0;
                this.bscale = header.get("BSCALE") || 1;
            }

            _getRows(buffer, nRows) {
                var accessor, arr, blank, data, i, index, j, len, len1, n, nTile, offset, r, rIndex, ref, row, scale, seed0, seed1, value, view, zero;

                // Set up view and offset
                view = new DataView(buffer);
                offset = 0;

                // Set up storage for frame
                arr = new Float32Array(this.width * this.height);

                // Read each row (tile)
                while (nRows--) {

                    // Storage for current row
                    row = {};
                    ref = this.accessors;
                    for (index = j = 0, len = ref.length; j < len; index = ++j) {
                        accessor = ref[index];

                        // Read value from each column in current row
                        [value, offset] = accessor(view, offset);
                        row[this.columns[index]] = value;
                    }

                    // Get array from column with returned values
                    // TODO: Check that data is returned correctly when UNCOMPRESSED_DATA or GZIP_COMPRESSED_DATA present
                    data = row['COMPRESSED_DATA'] || row['UNCOMPRESSED_DATA'] || row['GZIP_COMPRESSED_DATA'];
                    blank = row['ZBLANK'] || this.zblank;
                    scale = row['ZSCALE'] || this.bscale;
                    zero = row['ZZERO'] || this.bzero;

                    // Set initial seeds using tile number and ZDITHER0 (assuming row by row tiling)
                    nTile = this.height - nRows;
                    seed0 = nTile + this.zdither - 1;
                    seed1 = (seed0 - 1) % 10000;

                    // Set initial index in random sequence
                    rIndex = parseInt(this.constructor.randomSequence[seed1] * 500);
                    for (index = n = 0, len1 = data.length; n < len1; index = ++n) {
                        value = data[index];

                        // Get the pixel index
                        i = (nTile - 1) * this.width + index;
                        if (value === -2147483647) {
                            arr[i] = 0/0;
                        } else if (value === -2147483646) {
                            arr[i] = 0;
                        } else {
                            r = this.constructor.randomSequence[rIndex];
                            arr[i] = (value - r + 0.5) * scale + zero;
                        }

                        // Update the random index
                        rIndex += 1;
                        if (rIndex === 10000) {
                            seed1 = (seed1 + 1) % 10000;
                            rIndex = parseInt(this.randomSequence[seed1] * 500);
                        }
                    }
                }
                return arr;
            }


            // Even though compressed images are represented as a binary table
            // the API should expose the same method as images.
            // TODO: Support compressed data cubes
            getFrame(nFrame, callback, opts) {
                var heapBlob, reader;

                // Check if heap in memory
                if (this.heap) {
                    this.frame = nFrame || this.frame;

                    // TODO: Row parameters should be adjusted when working with data cubes
                    return this.getRows(0, this.rows, callback, opts);
                } else {
                    // Get blob representing heap
                    heapBlob = this.blob.slice(this.length, this.length + this.heapLength);

                    // Create file reader
                    reader = new FileReader();
                    reader.onloadend = (e) => {
                        this.heap = e.target.result;

                        // Call function again
                        return this.getFrame(nFrame, callback, opts);
                    };
                    return reader.readAsArrayBuffer(heapBlob);
                }
            }

        };

        CompressedImage.include(ImageUtils);

        CompressedImage.extend(Decompress);


        // Store random look up table on class.
        CompressedImage.randomSequence = CompressedImage.randomGenerator();

        return CompressedImage;

    }).call(this);

    this.astro.FITS.CompressedImage = CompressedImage;


    // # An extension to the CompressedImage class adding getFrameAsync
    // CompressedImage = @astro.FITS.CompressedImage

    // CompressedImage::getFrameAsync = (@frame = @frame, callback, opts = undefined) ->

    //   # Define the function to be executed on the worker thread
    //   onmessage = (e) ->
    //     # Cache variables
    //     data          = e.data
    //     tableLength   = data.tableLength
    //     tableColumns  = data.tableColumns
    //     columnNames   = data.columnNames
    //     params        = data.params
    //     ztile         = data.ztile
    //     rowByteSize   = data.rowByteSize
    //     zblank        = data.zblank
    //     bscale        = data.bscale
    //     bzero         = data.bzero
    //     width         = data.width
    //     height        = data.height
    //     blank         = data.blank
    //     bitpix        = data.bitpix
    //     buffer        = data.buffer
    //     urlRice       = data.urlRice

    //     dataAccessors =
    //       L: (view, offset) ->
    //         x = view.getInt8(offset)
    //         offset += 1
    //         val = if x is 84 then true else false
    //         return [val, offset]
    //       B: (view, offset) ->
    //         val = view.getUint8(offset)
    //         offset += 1
    //         return [val, offset]
    //       I: (view, offset) ->
    //         val = view.getInt16(offset)
    //         offset += 2
    //         return [val, offset]
    //       J: (view, offset) ->
    //         val = view.getInt32(offset)
    //         offset += 4
    //         return [val, offset]
    //       K: (view, offset) ->
    //         highByte = Math.abs view.getInt32(offset)
    //         offset += 4
    //         lowByte = Math.abs view.getInt32(offset)
    //         offset += 4
    //         mod = highByte % 10
    //         factor = if mod then -1 else 1
    //         highByte -= mod
    //         console.warn "Precision for 64 bit integers may be incorrect."
    //         val = factor * ((highByte << 32) | lowByte)
    //         return [val, offset]
    //       A: (view, offset) ->
    //             val = view.getChar(offset)
    //             offset += 1
    //             return [val, offset]
    //       E: (view, offset) ->
    //         val = view.getFloat32(offset)
    //         offset += 4
    //         return [val, offset]
    //       D: (view, offset) ->
    //         val = view.getFloat64(offset)
    //         offset += 8
    //         return [val, offset]
    //       C: (view, offset) ->
    //         val1 = view.getFloat32(offset)
    //         offset += 4
    //         val2 = view.getFloat32(offset)
    //         offset += 4
    //         val = [val1, val2]
    //         return [val, offset]
    //       M: (view, offset) ->
    //         val1 = view.getFloat64(offset)
    //         offset += 8
    //         val2 = view.getFloat64(offset)
    //         offset += 8
    //         val = [val1, val2]
    //         return [val, offset]

    //     RiceSetup =
    //       # Set up for bytepix = 1
    //       1: (array) ->
    //         pointer = 0
    //         fsbits = 3
    //         fsmax = 6

    //         lastpix = array[pointer]
    //         pointer += 1

    //         return [fsbits, fsmax, lastpix, pointer]

    //       # Set up for bytepix = 2
    //       2: (array) ->
    //         pointer = 0
    //         fsbits = 4
    //         fsmax = 14

    //         lastpix = 0
    //         bytevalue = array[pointer]
    //         pointer += 1
    //         lastpix = lastpix | (bytevalue << 8)
    //         bytevalue = array[pointer]
    //         pointer += 1
    //         lastpix = lastpix | bytevalue

    //         return [fsbits, fsmax, lastpix, pointer]

    //       # Set up for bytepix = 4
    //       4: (array) ->
    //         pointer = 0
    //         fsbits = 5
    //         fsmax = 25

    //         lastpix = 0
    //         bytevalue = array[pointer]
    //         pointer += 1
    //         lastpix = lastpix | (bytevalue << 24)
    //         bytevalue = array[pointer]
    //         pointer += 1
    //         lastpix = lastpix | (bytevalue << 16)
    //         bytevalue = array[pointer]
    //         pointer += 1
    //         lastpix = lastpix | (bytevalue << 8)
    //         bytevalue = array[pointer]
    //         pointer += 1
    //         lastpix = lastpix | bytevalue

    //         return [fsbits, fsmax, lastpix, pointer]

    //     importScripts(urlRice)

    //     # Define object of typed array constructors
    //     typedArray =
    //       B: Uint8Array
    //       I: Uint16Array
    //       J: Int32Array
    //       E: Float32Array
    //       D: Float64Array
    //       1: Uint8Array
    //       2: Uint16Array
    //       4: Int32Array

    //     # Set variables
    //     offset = 0
    //     rowsRead = 0
    //     accessors = []

    //     # Initialize a DataView object
    //     view = new DataView(buffer)

    //     #
    //     # Define various functions
    //     # NOTE: These function cannot use any instance variables.
    //     #

    //     # Define swap endian functions
    //     switch Math.abs(bitpix)
    //       when 16
    //         swapEndian = (value) ->
    //           return (value << 8) | (value >> 8)
    //       when 32
    //         swapEndian = (value) ->
    //           return ((value & 0xFF) << 24) | ((value & 0xFF00) << 8) | ((value >> 8) & 0xFF00) | ((value >> 24) & 0xFF)
    //       else
    //         swapEndian = (value) -> return value

    //     getFromHeap = (descriptor) ->
    //       # Get length and offset of the heap
    //       length = view.getInt32(offset)
    //       offset += 4
    //       heapOffset = view.getInt32(offset)
    //       offset += 4

    //       chunkOffset = tableLength + heapOffset

    //       # Read from the buffer
    //       chunk = view.buffer.slice(chunkOffset, chunkOffset + length)
    //       arr = new typedArray[descriptor](chunk)

    //       # Swap endian
    //       i = arr.length
    //       while i--
    //         arr[i] = swapEndian(arr[i])

    //       return arr

    //     setAccessors = ->
    //       pattern = /(\d*)([P|Q]*)([L|X|B|I|J|K|A|E|D|C|M]{1})/
    //       for column, i in tableColumns
    //         form = Object.keys(column)[0]
    //         type = column[form]
    //         match = pattern.exec(form)

    //         count       = parseInt(match[1]) or 1
    //         isArray     = match[2]
    //         descriptor  = match[3]

    //         if isArray  # Rarely will this be false for compressed images
    //           # Handle array descriptors
    //           switch type
    //             when "COMPRESSED_DATA"
    //               do (descriptor, count) =>
    //                 accessor = =>
    //                   arr = getFromHeap(descriptor)

    //                   # Assuming Rice compression
    //                   pixels = new typedArray[params["BYTEPIX"]](ztile[0])

    //                   # Bring in Rice using technique at
    //                   # http://stackoverflow.com/questions/11909934/how-to-pass-functions-to-javascript-web-worker
    //                   Rice(arr, params["BLOCKSIZE"], params["BYTEPIX"], pixels, ztile[0], RiceSetup)

    //                   return pixels
    //                 accessors.push(accessor)
    //             when "GZIP_COMPRESSED_DATA"
    //               # TODO: Implement GZIP
    //               do (descriptor, count) =>
    //                 accessor = =>
    //                   # arr = @getFromHeap(descriptor)

    //                   # Temporarily padding with NaNs until GZIP is implemented
    //                   arr = new Float32Array(width)
    //                   i = arr.length
    //                   while i--
    //                     arr[i] = NaN
    //                   return arr
    //                 accessors.push(accessor)
    //             else
    //               do (descriptor, count) =>
    //                 accessor = =>
    //                   return getFromHeap(descriptor)
    //                 accessors.push(accessor)
    //         else
    //           if count is 1
    //             # Handle single element
    //             do (descriptor, count) =>
    //               accessor = =>
    //                 [value, offset] = dataAccessors[descriptor](view, offset)
    //                 return value
    //               accessors.push(accessor)
    //           else
    //             # Handle bit arrays
    //             if descriptor is 'X'
    //               do (descriptor, count) =>
    //                 nBytes = Math.log(count) / Math.log(2)
    //                 accessor = =>
    //                   # Read from the buffer
    //                   chunk = view.buffer.slice(offset, offset + nBytes)
    //                   bytes = new Uint8Array(chunk)

    //                   # Get bit representation
    //                   bits = []
    //                   for byte in bytes
    //                     arr = @toBits(byte)
    //                     bits = bits.concat(arr)

    //                   # Increment the offset
    //                   offset += nBytes

    //                   return bits[0..count - 1]
    //                 accessors.push(accessor)

    //             # Handle character arrays
    //             else if descriptor is 'A'
    //               do (descriptor, count) =>
    //                 accessor = =>
    //                   str = view.getString(offset, count)
    //                   @offset += count
    //                   return str.trim()
    //                 accessors.push(accessor)

    //             # Handle all other data types
    //             else
    //               do (descriptor, count) =>
    //                 accessor = =>
    //                   # TypedArray = @typedArray[descriptor]
    //                   #
    //                   # # Read from the buffer
    //                   # length = count * TypedArray.BYTES_PER_ELEMENT
    //                   # chunk = view.buffer.slice(@offset, @offset + length)
    //                   # @offset += length
    //                   #
    //                   # return new TypedArray(chunk)

    //                   data = []
    //                   while count--
    //                     [value, offset] = dataAccessors[descriptor](view, offset)
    //                     data.push(value)
    //                   return data
    //                 accessors.push(accessor)

    //     getTableRow = ->
    //       offset = rowsRead * rowByteSize
    //       row = []
    //       for accessor in accessors
    //         row.push accessor()

    //       data  = row[columnNames["COMPRESSED_DATA"]] or row[columnNames["UNCOMPRESSED_DATA"]] or row[columnNames["GZIP_COMPRESSED_DATA"]]
    //       blank = row[columnNames["ZBLANK"]] or zblank
    //       scale = row[columnNames["ZSCALE"]] or bscale
    //       zero  = row[columnNames["ZZERO"]] or bzero
    //       return [data, blank, scale, zero]

    //     # TODO: Test this function.  Need example file with blanks.
    //     getRowHasBlanks = (arr) ->
    //       [data, blank, scale, zero] = getTableRow()

    //       offset = rowsRead * width
    //       for value, index in data
    //         i = offset + index
    //         arr[i] = if value is blank then NaN else (zero + scale * value)
    //       rowsRead += 1

    //     getRowNoBlanks = (arr) ->
    //       [data, blank, scale, zero] = getTableRow()

    //       offset = rowsRead * width
    //       for value, index in data
    //         i = offset + index
    //         arr[i] = zero + scale * value
    //       rowsRead += 1

    //     defGetRow = ->
    //       hasBlanks = zblank? or blank? or columnNames.hasOwnProperty("ZBLANK")
    //       return if hasBlanks then getRowHasBlanks else getRowNoBlanks

    //     getFrame = ->
    //       arr = new Float32Array(width * height)

    //       rowsRead = 0
    //       while height--
    //         getRow(arr)

    //       return arr

    //     setAccessors(tableColumns, view)
    //     getRow = defGetRow()

    //     arr = getFrame()
    //     data =
    //       offset: offset
    //       arr: arr

    //     postMessage(data)

    //   # Trick to format function for worker
    //   fn1 = onmessage.toString().replace('return postMessage(data);', 'postMessage(data);')
    //   fn1 = "onmessage = #{fn1}"

    //   # Functions passed to worker via url cannot be anonymous
    //   fn2 = @constructor.Rice.toString()
    //   fn2 = fn2.replace('function', 'function Rice')

    //   # Construct blob for an inline worker and Rice algorithm
    //   mime = "application/javascript"
    //   blobOnMessage = new Blob([fn1], {type: mime})
    //   blobRice = new Blob([fn2], {type: mime})

    //   # Prefix for Safari
    //   URL = window.URL or window.webkitURL or window.MozURLProperty
    //   urlOnMessage = URL.createObjectURL(blobOnMessage)
    //   urlRice = URL.createObjectURL(blobRice)

    //   # Initialize worker
    //   worker = new Worker(urlOnMessage)

    //   # Define function for when worker job is complete
    //   worker.onmessage = (e) ->
    //     arr = e.data.arr

    //     # Execute callback
    //     callback.call(@, arr, opts) if callback?

    //     # Clean up blob urls and worker
    //     URL.revokeObjectURL(urlOnMessage)
    //     # URL.revokeObjectURL(urlRice)
    //     worker.terminate()

    //   # Information to pass to worker
    //   data =
    //     buffer: @view.buffer.slice(@begin, @begin + @length)
    //     tableLength: @tableLength
    //     tableColumns: @tableColumns
    //     columnNames: @columnNames
    //     params: @algorithmParameters
    //     ztile: @ztile
    //     rowByteSize: @rowByteSize
    //     zblank: @zblank
    //     bscale: @bscale
    //     bzero: @bzero
    //     width: @width
    //     height: @height
    //     blank: @blank
    //     urlRice: urlRice

    //   # Pass object to worker
    //   worker.postMessage(data)

    // Header data unit to store a header and its associated data unit
    HDU = class HDU {
        constructor(header1, data1) {
            this.header = header1;
            this.data = data1;
        }

        hasData() {
            if (this.data != null) {
                return true;
            } else {
                return false;
            }
        }

    };

    this.astro.FITS.HDU = HDU;

}).call(this);
